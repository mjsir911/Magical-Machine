load #1 to register 1
load #2 to register 2
store reg 2 to somewhere#0
reg 2 = // 256
store reg 2 to somewhere#1
reg 1 = + somewhere#1
store reg 1 to somewhere#2

set address# to paddress#
set bits# to pbits#
set isetnum# to pisetnum#

func train:
load somewhere#2 to reg 1
sub register by bits#
cjump to address#
load address# to reg 1
add isetnum# to reg 1
store reg 1 to address#
load bits# to reg 1
add isetnum# to reg 1
store reg 1 to bits#
:jump to top

address# (address for first address)
bits# (address for first bits)
isetnum#

paddress#
pbits#
pisetnum#



end of func train:
set totale to opcode

load second half of aline (line - first half * 256)
subtract from 48
mult by 256
add to grande total

load #3 aline
get first half by aline // 256
dupe
div by 58
if 0 jump past block #1
  sub 55
mul by 8
add to grande totale

get second half of aline
dupe
div by 58
if 0 jump past block #2
  sub 55
add to grande totale


add 1 to #1
add 1 to #2
add 1 to #3
jump to top
addresses:
jump-address(0000000000000000)
1 (needed to add 1)
end of block #2
end of block #1
end of func train addr

add-bits:   0110000111001000
add-opcode: 0000110000000000
add-address: c-address + 1
add-func:
  load opcode
  jump back to end of func train

sub-bits:   
sub-opcode: 
sub-address: c-address + 1
sub-func:
  load opcode
  jump back to end of func train
